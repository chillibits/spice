grammar Spice;

entry: (stmt | function_def | procedure_def)*;
function_def: F LESS DATA_TYPE GREATER IDENTIFIER LPAREN param_lst RPAREN LBRACE stmt_lst RBRACE;
procedure_def: P IDENTIFIER LPAREN param_lst RPAREN LBRACE stmt_lst RBRACE;
for_loop: FOR assignment SEMICOLON top_lvl_expr SEMICOLON top_lvl_expr LBRACE stmt_lst RBRACE;
for_each_loop: FOREACH IDENTIFIER COLON value LBRACE stmt_lst RBRACE;
while_loop: WHILE top_lvl_expr LBRACE stmt_lst RBRACE;
if_stmt: IF top_lvl_expr LBRACE stmt_lst RBRACE;

stmt_lst: (stmt | for_loop | for_each_loop | while_loop | if_stmt)*;
param_lst: (decl_stmt | assignment)? (COMMA (decl_stmt | assignment))*;
stmt: (decl_stmt | assignment | function_call | top_lvl_expr | import_stmt | return_stmt) SEMICOLON;
decl_stmt: CONST? DATA_TYPE IDENTIFIER;
function_call: IDENTIFIER LPAREN param_lst RPAREN;
import_stmt: IMPORT STRING;
return_stmt: RETURN top_lvl_expr;

top_lvl_expr: assignment;
assignment: ((decl_stmt | IDENTIFIER) (ASSIGN_OP | PLUS_EQUAL | MINUS_EQUAL | MUL_EQUAL | DIV_EQUAL))? ternary;
ternary: logical_or_expr (QUESTION_MARK logical_or_expr ':' logical_or_expr)?;
logical_or_expr: logical_and_expr (LOGICAL_OR logical_and_expr)*;
logical_and_expr: bitwise_or_expr (LOGICAL_AND bitwise_or_expr)*;
bitwise_or_expr: bitwise_and_expr (BITWISE_OR bitwise_and_expr)*;
bitwise_and_expr: equality (BITWISE_AND equality)*;
equality: relational_expr ((EQUAL | NOT_EQUAL) relational_expr)?;
relational_expr: additive_expr ((LESS | GREATER | LESS_EQUAL | GREATER_EQUAL) additive_expr)?;
additive_expr: multiplicative_expr ((PLUS | MINUS) multiplicative_expr)*;
multiplicative_expr: prefix_unary ((MUL | DIV) prefix_unary)*;
prefix_unary: (NOT | PLUS_PLUS | MINUS_MINUS)? postfix_unary;
postfix_unary: atomic_expr (PLUS_PLUS | MINUS_MINUS)?;
atomic_expr: value | LPAREN additive_expr RPAREN;
value: STRING | BOOL | INTEGER | DOUBLE | IDENTIFIER | function_call;

DATA_TYPE: 'double' | 'int' | 'string' | 'bool' | 'dyn';
F: 'f';
P: 'p';
IF: 'if';
FOR: 'for';
FOREACH: 'foreach';
WHILE: 'while';
CONST: 'const';
IMPORT: 'import';
RETURN: 'return';
IDENTIFIER: [_a-zA-Z][_a-zA-Z0-9]*;
INTEGER: '-'* [1-9]+[0-9]* | '0';
DOUBLE: '-'* [0-9]+.[0-9]+;
STRING: '"' (~["\\\r\n] | '\\' (. | EOF))* '"';
BOOL: TRUE | FALSE;
TRUE: 'true';
FALSE: 'false';
LBRACE: '{';
RBRACE: '}';
LPAREN: '(';
RPAREN: ')';
LBRACKET: '[';
RBRACKET: ']';
LOGICAL_OR: '||';
LOGICAL_AND: '&&';
BITWISE_OR: '|';
BITWISE_AND: '&';
NOT: '!';
PLUS_PLUS: '++';
MINUS_MINUS: '--';
PLUS_EQUAL: '+=';
MINUS_EQUAL: '-=';
MUL_EQUAL: '*=';
DIV_EQUAL: '/=';
PLUS: '+';
MINUS: '-';
MUL: '*';
DIV: '/';
GREATER: '>';
LESS: '<';
GREATER_EQUAL: '>=';
LESS_EQUAL: '<=';
EQUAL: '==';
NOT_EQUAL: '!=';
ASSIGN_OP: '=';
QUESTION_MARK: '?';
SEMICOLON: ';';
COLON: ':';
COMMA: ',';

COMMENT: '/*' .*? '*/' -> skip;
LINE_COMMENT: '//' ~[\r\n]* -> skip;
WS: [ \t\r\n]+ -> channel(HIDDEN);